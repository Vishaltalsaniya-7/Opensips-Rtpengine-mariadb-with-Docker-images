#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      https://opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#


####### Global Parameters #########

/* uncomment the following lines to enable debugging */
#debug_mode=yes

log_level=3
xlog_level=3
stderror_enabled=yes
syslog_enabled=no
syslog_facility=LOG_LOCAL0

udp_workers=4

/* uncomment the next line to enable the auto temporary blacklisting of
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns
   lookup failures (default disabled) */
#dns_try_ipv6=yes


socket=udp:0.0.0.0:5062   # CUSTOMIZE ME


alias="172.27.191.2"

####### Modules Section ########

#set module path
mpath="/usr/lib/x86_64-linux-gnu/opensips/modules/"

#### SIGNALING module
loadmodule "signaling.so"

#### StateLess module
loadmodule "sl.so"

#### Transaction Module
loadmodule "tm.so"
modparam("tm", "fr_timeout", 5)
modparam("tm", "fr_inv_timeout", 30)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

#### Record Route Module
loadmodule "rr.so"
/* do not append from tag to the RR (no need for this script) */
modparam("rr", "append_fromtag", 0)

# Core SIP user registration and authentication modules
loadmodule "auth.so"
loadmodule "auth_db.so"
loadmodule "db_mysql.so"

#### MAX ForWarD module
loadmodule "maxfwd.so"

#### SIP MSG OPerationS module
loadmodule "sipmsgops.so"

#### FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/run/opensips/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

#### USeR LOCation module
loadmodule "usrloc.so"
modparam("usrloc", "nat_bflag", "NAT")
# modparam("usrloc", "working_mode_preset", "single-instance-no-db")

# Database connection for user location
modparam("usrloc", "db_url", "mysql://opensips:opensipsrw@db/opensips")
modparam("auth_db", "db_url", "mysql://opensips:opensipsrw@db/opensips")

# DB-based authentication
modparam("auth_db", "calculate_ha1", yes)
modparam("auth_db", "password_column", "ha1")

#### REGISTRAR module
loadmodule "registrar.so"
modparam("registrar", "tcp_persistent_flag", "TCP_PERSISTENT")
/* uncomment the next line not to allow more than 10 contacts per AOR */
#modparam("registrar", "max_contacts", 10)

#### ACCounting module
loadmodule "acc.so"
/* what special events should be accounted ? */
modparam("acc", "early_media", 0)
modparam("acc", "report_cancels", 0)
/* by default we do not adjust the direct of the sequential requests.
   if you enable this parameter, be sure to enable "append_fromtag"
   in "rr" module */
modparam("acc", "detect_direction", 0)

loadmodule "proto_udp.so"

loadmodule "rtpengine.so"
# modparam("rtpengine", "rtpengine_sock", "udp:178.28.0.2:22222")
modparam("rtpengine", "rtpengine_sock", "udp:172.27.191.2:22222")

# modparam("rtpengine", "log_level", 3)


####### Routing Logic ########

# main request routing logic

route{

        if (!mf_process_maxfwd_header(10)) {
                send_reply(483,"Too Many Hops");
                exit;
        }

        if (has_totag()) {

                # handle hop-by-hop ACK (no routing required)
                if ( is_method("ACK") && t_check_trans() ) {
                        t_relay();
                        exit;
                }

                # sequential request within a dialog should
                # take the path determined by record-routing
                if ( !loose_route() ) {
                        # we do record-routing for all our traffic, so we should not
                        # receive any sequential requests without Route hdr.
                        send_reply(404,"Not here");
                        exit;
                }

                if (is_method("BYE")) {
                        # do accounting even if the transaction fails
                        do_accounting("log","failed");
                }

                # route it out to whatever destination was set by loose_route()
                # in $du (destination URI).
                route(relay);
                exit;
        }

        # CANCEL processing
        if (is_method("CANCEL")) {
                if (t_check_trans())
                        t_relay();
                exit;
        }

        # absorb retransmissions, but do not create transaction
        t_check_trans();

        if ( !(is_method("REGISTER")  ) ) {

                if (is_myself("$fd")) {

                } else {
                        # if caller is not local, then called number must be local

                        if (!is_myself("$rd")) {
                                send_reply(403,"Relay Forbidden");
                                exit;
                        }
                }

        }

        # preloaded route checking
        if (loose_route()) {
                xlog("L_ERR",
                        "Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
                if (!is_method("ACK"))
                        send_reply(403,"Preload Route denied");
                exit;
        }

        # record routing
        if (!is_method("REGISTER|MESSAGE"))
                record_route();

        # account only INVITEs
        if (is_method("INVITE")) {

                do_accounting("log");
        }


        if (!is_myself("$rd")) {
                append_hf("P-hint: outbound\r\n");

                route(relay);
        }

        # requests for my domain

        if (is_method("PUBLISH|SUBSCRIBE")) {
                send_reply(503, "Service Unavailable");
                exit;
        }

        # if (is_method("REGISTER")) {
        #         # store the registration and generate a SIP reply
        #         if (!save("location"))
        #                 xlog("failed to register AoR $tu\n");

        #         exit;
        # }

        if (!save("location")) {
            xlog("L_ERR", "Failed to save registration for $tu\n");
            } else {
            xlog("L_INFO", "Registration saved for $tu\n");
        }


        if ($rU==NULL) {
                # request with no Username in RURI
                send_reply(484,"Address Incomplete");
                exit;
        }

        # do lookup with method filtering
        if (!lookup("location","method-filtering")) {
                t_reply(404, "Not Found");
                exit;
        }

        # when routing via usrloc, log the missed calls also
        do_accounting("log","missed");
        route(relay);
}


route[relay] {
        # for INVITEs enable some additional helper routes
        if (is_method("INVITE")) {
                 xlog("L_INFO", "Processing INVITE - calling rtpengine_offer\n");
        
        # Call RTP engine with proper flags for offer processing
        if (rtpengine_offer("replace-origin replace-session-connection ICE=remove")) {
            xlog("L_INFO", "RTP engine offer successful\n");
        } else {
            xlog("L_ERR", "RTP engine offer failed - error code: $retcode\n");
            # Continue without RTP proxying but log the error
        }
                t_on_branch("per_branch_ops");
                t_on_reply("handle_nat");
                t_on_failure("missed_call");
        }

        if (!t_relay()) {
                send_reply(500,"Internal Error");
        }
        exit;
}




branch_route[per_branch_ops] {
        xlog("new branch at $ru\n");
}


onreply_route[handle_nat] {
        xlog("incoming reply\n");
        if (is_method("INVITE") && t_check_status("200")) {
        xlog("L_INFO", "Processing 200 OK - calling rtpengine_answer\n");
        
        # Handle RTP for 200 OK responses  
        if (rtpengine_answer("replace-origin replace-session-connection ICE=remove")) {
            xlog("L_INFO", "RTP engine answer successful\n");
        } else {
            xlog("L_ERR", "RTP engine answer failed - error code: $retcode\n");
        }
    }
}


failure_route[missed_call] {
        if (t_was_cancelled()) {
                exit;
        }

        # uncomment the following lines if you want to block client
        # redirect based on 3xx replies.
        ##if (t_check_status("3[0-9][0-9]")) {
        ##t_reply(404,"Not found");
        ##      exit;
        ##}


}


